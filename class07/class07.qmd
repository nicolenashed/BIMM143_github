---
title: "Class 07: Machine Learning 1"
author: "Nashed (PID: A16631132)"
format: pdf
---

#Clustering 

We will start today's lab with clustering methods, in particular so-called K-means. The main function for this in R is `kmeans()`. 

Let's try it on some made up data where we know what the answer should be. 

```{r}
x <- rnorm(10000,mean=3)
hist(x)
```

We can pass this to the base R plot `plot()` function for a quick. 
```{r}
tmp <- c(rnorm(30,mean=3), rnorm(30, mean=-3))
x <- cbind(x=tmp, y=rev(tmp))
head(x)
```

```{r}
plot(x)
```

```{r}
k <- kmeans(x, centers=2, nstart= 20)
```

> Q1. How many points are in each cluster? 

```{r}
k$size
```
> Q2. Cluster membership? 

```{r}
k$cluster
```

> Q3. Cluster centers? 

```{r}
k$centers
```
>Q4. Plot my clustering results 

```{r}
plot(x, col=k$cluster, pch=16)
```
>Q5. Cluster the data again with kmeans() into 4 groups and plot the results. 

```{r}
k4 <- kmeans(x, centers=4, nstart=20)
plot(x, col=k4$cluster, pch=16)
```
K-means is very popular mostly because it is fast and relatively straightforward to run and understand. It has a big limitation in that you need to tell it how many groups (k, or centers) you want. 

#Hierarchical clustering

The main function in base R is called `hclust()`. You have to pass it in a "distance matrix" not just your input data. 

You can generate a distance matrix with the `dist()` function.

```{r}
hc <- hclust( dist(x) )
hc
```
```{r}
plot(hc)
```
to find the clusters (cluster membership vector) from a `hclust()` result we can "cut" the tree at a certain height that we like. 

```{r}
plot(hc)
abline(h=8, col="red")
grps <- cutree(hc, h=8)
```


```{r}
table(grps)
```
>Q6. Plot our hclust results. 


#Principal Component Analysis 

##PCA of UK food data 

Read data showing the consumption in grams (per person, per week) of 17 different types of food-stuff measured and averaged in the four countries of the United Kingdom. 

Lets see how PCA can help us but first we can try conventional analysis. 

```{r}
url <- "https://tinyurl.com/UK-foods"
x <- read.csv(url)
x
```
```{r}
dim(x)
```
>Q1. How many rows and columns are in your new data frame named x? What R functions could you use to answer this questions?
There are 5 columns and 17 rows. You can use either dim(x); or ncol(x) and nrow(x) to get them independently. 

```{r}
rownames(x) <- x[,1]
x <- x[,-1]
head(x)
```

```{r}
dim(x)
```
```{r}
rownames(x) <- x[,1]
x <- x[,-1]
head(x)
```
```{r}
url <- "https://tinyurl.com/UK-foods"
x <- read.csv(url, row.names=1)
head(x)
```
>Q2. Which approach to solving the ‘row-names problem’ mentioned above do you prefer and why? Is one approach more robust than another under certain circumstances?
I prefer the second one because if you keep running the first one again and again it shifts the data to the left and gets rid of valuable information. 

```{r}
barplot(as.matrix(x), beside=T, col=rainbow(nrow(x)))
```
```{r}
barplot(as.matrix(x), beside=FALSE, col=rainbow(nrow(x)))
```

>Q3. Changing what optional argument in the above barplot() function results in the following plot?
If you change beside(T) to beside=FALSE, then the barplot will result in the above plot. 

```{r}
pairs(x, col=rainbow(17), pch=16) 
```
>Q5: Generating all pairwise plots may help somewhat. Can you make sense of the following code and resulting figure? What does it mean if a given point lies on the diagonal for a given plot?
If the given point lies on the diagonal that means that the two countries consume the same amount and there are very similair amounts of food consumed in both of the countries being compared. Any deviation from the diagonal (above or below) means there is more or less being consumed compared to the other country. 

>Q6. What is the main differences between N. Ireland and the other countries of the UK in terms of this data-set?
N. Ireland is the outlier between all the other countries and it seems like they might eat different amounts of fresh potatoes.  

#Principal Component Analysis (PCA)

PCA can help us make sense of these types of datasets. Let's see how it works. 

The main function in "base" R is called `prcomp()`. In this case we want to first take the transpose `t()` of our input`x` so the columns are the food types and the countries are the rows. 

```{r}
head(t(x))
```

```{r}
pca <-  prcomp(t(x))
summary(pca)
```
>Q7. Complete the code below to generate a plot of PC1 vs PC2. The second line adds text labels over the data points.

```{r}
pca$x
```


```{r}
plot(pca$x[,1], pca$x[,2], 
     col=c("orange", "red", "blue", "darkgreen"),
     pch=16)
```
```{r}
plot(pca$x[,1], pca$x[,2], xlab="PC1", ylab="PC2", xlim=c(-270,500))
text(pca$x[,1], pca$x[,2], colnames(x))
```
```{r}
plot(pca$x[,1], pca$x[,2], col=c("orange", "red", "blue", "darkgreen" ), pch=16)
text(pca$x[,1], pca$x[,2], colnames(x),col=c("orange", "red", "blue", "darkgreen") )
```
>Q8  Customize your plot so that the colors of the country names match the colors in our UK and Ireland map and table at start of this document.

```{r}
pca$rotation
```
The "loadings" tell us how much the original variables 

```{r}
par(mar=c(10, 3, 0.35, 0))
barplot( pca$rotation[,1], las=2 )
```




```{r}
par(mar=c(10, 3, 0.35, 0))
barplot( pca$rotation[,2], las=2 )
```

>Q9. Generate a similar ‘loadings plot’ for PC2. What two food groups feature prominantely and what does PC2 maninly tell us about?
PC2 mainly tells us about the different food groups between the countries and PC2 accounts for any of the variance that was not in PC1. It looks like fresh potatoes and soft drinks are different food groups. 

